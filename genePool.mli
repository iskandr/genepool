(*
	GenePool: A simple evolutionary algorithm library for OCaml (version 1.01)
	by Alex Rubinsteyn (alex -dot- rubinsteyn -at- gmail -dot- com)
	
	Free for use under the LGPL (http://www.gnu.org/licenses/lgpl-3.0.txt)	
*)

(*
	GA Specification
	-------------------------------------------------------------------------------
		evaluate  - assign a fitness to a genome
		mutatate  - given a genome, create an altered copy
		crossover - given two genomes, combine them
		genRandom - produce a random genome from scratch
		report    - optionally output information about the best genome of each generation 
		seed      - optional initial seed population
		stop      - optional stopping predicate
*)

type ('genome, 'fitness) ga_spec = {
		evaluate : 'genome -> 'fitness;
		mutate : 'genome -> 'genome;
		crossover : ('genome * 'genome) -> 'genome;
		genRandom: unit -> 'genome;
		seed: 'genome array option;
		report: (int -> 'genome -> 'fitness -> unit) option;
		stop : (int -> 'genome -> 'fitness -> bool) option
}

(*
	GA Parameters
	-------------------------------------------------------------------------------
	nRandom - how many random genomes should we generate at the beginning
	nSurvivors - how many genomes survive of each generation 
	nMutations - # new genomes generated by asexual reproduction in each generation
	nCrossovers - # new genomes  by sexual reproduction in each generation 
	timeLimit - seconds until algorithm termination 
	maxGen - maximum number of generations until algorithm termination 
*)

type ga_params = {
	nRandom: int;
	nSurvivors: int;
	nMutations: int;
	nCrossovers: int;
	timeLimit:float;
	maxGen: int
}

exception GenePoolError of string

val evolve :  ('genome, 'fitness) ga_spec -> ga_params -> 'genome array * 'fitness

(* 
   Useful utility functions to make your life easier
   ----------------------------------------------------
   selectRandom    - given an array of functions and an input, apply one of those functions
									   to an input with uniform probability. 
										 (useful for using multiple mutation or crossover functions)
	
	 randIntExcept   - given parameters n and e, generate a pseudorandom number in [0, n) excluding e
	
	 goodRandom      - given a RNG and predicate, keep generating numbers until the predicate
	                   is satisfied
	
	 goodRandomInt   - works like goodRandom, but generates specifically integers with values
	                   up to the first argument
	
	 gaussRandom     - takes parameter mean,sigma and samples from that 1D normal distribution
	 
*)
										
module Utility : sig
	val selectRandom : ('input -> 'output) array -> 'input -> 'output
	val randIntExcept : int -> int -> int 
	val goodRandom : (unit -> 'random) -> ('random -> bool) -> 'random 
	val goodRandomInt : int -> (int -> bool) -> int 
	val gaussRandom : float -> float -> unit -> float 
end

(*
		Array genome operations 
		-------------------------------------
		mutate            - modify each element of an array with probability given by first argument; 
							            (at least one position is modified)

		mutatePoint       - modify exactly one position in the array 
		
		mutateWhenPred    - modify exactly one position when its index satisfies a predicate 
		
		onePointCrossover - first part of new genome comes from first array, latter part comes from second array
		
		twoPointCrossover - genome is a copy of the first array with a range blitted from the second
		
		randomCrossover   - genome is a copy of the first array with a shifted range blitted from the second
		
		mkArray           - create an array of given length using the supplied 0-arity function 
			                  (usually a pseudorandom number generator)
*)

module ArrayGenome : sig
	val mutate : float -> ('a -> 'a) -> 'a array -> 'a array
	val mutatePoint : ('a -> 'a) -> 'a array -> 'a array
	val mutateWhenPred : float -> ('a -> 'a) -> (int -> bool) -> 'a array -> 'a array
	val mutatePointWhenPred : ('a -> 'a) -> (int -> bool) -> 'a array -> 'a array
	val onePointCrossover : ('a array * 'a array) -> 'a array
	val twoPointCrossover : ('a array * 'a array) -> 'a array
	val randomCrossover : ('a array * 'a array) -> 'a array  
	val mkArray : int -> (unit -> 'a) -> unit -> 'a array
end